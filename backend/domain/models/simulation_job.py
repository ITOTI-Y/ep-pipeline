from datetime import datetime
from pathlib import Path
from typing import TYPE_CHECKING, Optional
from uuid import UUID, uuid4

from pydantic import BaseModel, Field, ConfigDict

from .enums import SimulationStatus, SimulationType

if TYPE_CHECKING:
    from .building import Building
    from .weather_file import WeatherFile
    from .simulation_result import SimulationResult
    from ..value_objects.ecm_parameters import ECMParameters

class SimulationJob(BaseModel):
    model_config = ConfigDict(
        validate_assignment=True,
        frozen=False,
        arbitrary_types_allowed=True,
    )

    building: "Building" = Field(
        ..., description="The building object associated with the simulation job."
    )
    weather_file: "WeatherFile" = Field(
        ..., description="The weather file object associated with the simulation job."
    )
    simulation_type: SimulationType = Field(
        ..., description="The type of simulation to be performed."
    )
    output_directory: Path = Field(
        ..., description="The directory where simulation outputs will be stored."
    )
    output_prefix: str = Field(
        ..., description="The prefix for output files generated by the simulation."
    )
    id: UUID = Field(
        default_factory=uuid4, description="Unique identifier for the simulation job."
    )
    created_at: datetime = Field(
        default_factory=datetime.now,
        description="Timestamp when the simulation job was created.",
    )
    status: SimulationStatus = Field(
        default=SimulationStatus.PENDING,
        description="Current status of the simulation job.",
    )

    read_variables: bool = Field(
        default=True,
        description="Whether to read variables from the EnergyPlus simulation.",
    )
    ecm_parameters: Optional["ECMParameters"] = Field(
        default=None,
        description="Energy Conservation Measures parameters for the simulation.",
    )
    started_at: Optional[datetime] = Field(
        default=None,
        description="Timestamp when the simulation job started.",
    )
    completed_at: Optional[datetime] = Field(
        default=None,
        description="Timestamp when the simulation job completed.",
    )
    result: Optional["SimulationResult"] = Field(
        default=None,
        description="The result of the simulation job.",
    )
    error_message: Optional[str] = Field(
        default=None,
        description="Error message if the simulation job failed.",
    )

    def start(self) -> None:
        """Mark the simulation job as started."""
        if self.status != SimulationStatus.PENDING:
            raise ValueError(
                f"Cannot start a job that is {self.status}."
                f" Only PENDING jobs can be started."
            )

        self.status = SimulationStatus.RUNNING
        self.started_at = datetime.now()

    def complete(self, result: "SimulationResult") -> None:
        """Mark the simulation job as completed."""
        if self.status != SimulationStatus.RUNNING:
            raise ValueError(
                f"Cannot complete a job that is {self.status}."
                f" Only RUNNING jobs can be completed."
            )

        self.status = SimulationStatus.COMPLETED
        if getattr(result, "job_id", None) != self.id:
            raise ValueError(
                f"Result job_id {getattr(result, 'job_id', None)} does not match SimulationJob id {self.id}."
            )
        self.completed_at = datetime.now()
        self.result = result

    def fail(self, error_message: str) -> None:
        """Mark the simulation job as failed."""
        if self.status.is_terminal() and self.status != SimulationStatus.RUNNING:
            raise ValueError(
                f"Cannot fail a job that is {self.status}."
                f" Job is already in a terminal state."
            )
        self.status = SimulationStatus.FAILED
        self.completed_at = datetime.now()
        self.error_message = error_message

    def cancel(self) -> None:
        """Mark the simulation job as cancelled."""
        if self.status.is_terminal():
            raise ValueError(
                f"Cannot cancel a job that is {self.status}."
                f" Job is already in a terminal state."
            )
        self.status = SimulationStatus.CANCELLED
        self.completed_at = datetime.now()

    def get_cache_key(self) -> str:
        building_id = self.building.get_identifier()
        weather_file_id = self.weather_file.get_identifier()
        ecm_hash = hash(self.ecm_parameters) if self.ecm_parameters else 0
        return (
            f"{building_id}_{weather_file_id}_{self.simulation_type.value}_{ecm_hash}"
        )

    def get_duration(self) -> Optional[float]:
        """Get the duration of the simulation job in seconds."""
        if self.started_at and self.completed_at:
            return (self.completed_at - self.started_at).total_seconds()
        return None

    def __str__(self) -> str:
        return (
            f"SimulationJob(id={self.id}, type={self.simulation_type.value}, "
            f"status={self.status.value})"
        )
